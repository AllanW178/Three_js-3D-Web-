<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive VRM Companion</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202025; }
        canvas { display: block; }
        /* Simple UI to prompt user */
        #ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-family: sans-serif;
            pointer-events: none;
            user-select: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
                "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui">Click the face to interact â€¢ Zoom in for reaction</div>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // --- 1. Scene & Camera ---
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.3, 1.4); 

        // Lighting
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1.3, 0);
        controls.minDistance = 0.3;
        controls.maxDistance = 4.0;
        // Restrict vertical angle so you can't go under the floor
        controls.maxPolarAngle = Math.PI / 1.8; 

        // --- 2. State & Variables ---
        let currentVrm = null;
        let blinkTimer = 0;
        
        // Interaction States
        const inputState = {
            isHappy: false,
            isSurprised: false,
            isBlushing: false
        };

        // Smooth values for expressions
        const expressionSmoothness = {
            joy: 0,
            surprised: 0,
            blink: 0
        };

        // --- 3. Raycaster (Click Interaction) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (event) => {
            if (!currentVrm) return;

            // Calculate mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // Check intersection with VRM
            const intersects = raycaster.intersectObjects(currentVrm.scene.children, true);
            
            if (intersects.length > 0) {
                // Get distance to head to distinguish Head click vs Body click
                const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                const headPos = new THREE.Vector3();
                head.getWorldPosition(headPos);
                
                const hitPoint = intersects[0].point;
                const distToHead = hitPoint.distanceTo(headPos);

                if (distToHead < 0.25) {
                    // Clicked Head -> Happy/Wink
                    triggerEmotion('isHappy', 2.0); // Lasts 2 seconds
                } else {
                    // Clicked Body -> Surprise
                    triggerEmotion('isSurprised', 1.0);
                }
            }
        });

        // Helper to handle temporary emotions
        function triggerEmotion(stateKey, duration) {
            inputState[stateKey] = true;
            setTimeout(() => {
                inputState[stateKey] = false;
            }, duration * 1000);
        }

        // --- 4. Load VRM ---
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));

        loader.load(
            '../VRM/Mafuyu_Black_Fit.vrm',
            (gltf) => {
                const vrm = gltf.userData.vrm;
                VRMUtils.removeUnnecessaryVertices(gltf.scene);
                VRMUtils.removeUnnecessaryJoints(gltf.scene);

                if (vrm.lookAt) vrm.lookAt.autoUpdate = false;
                
                scene.add(vrm.scene);
                currentVrm = vrm;
                
                // Rotate model to face front (VRM standard is +Z, WebGL standard is +Z, but usually need 180 rotation)
                vrm.scene.rotation.y = Math.PI; 

                // Arms A-Pose
                const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                if (leftArm) leftArm.rotation.z = Math.PI / 2.5;
                if (rightArm) rightArm.rotation.z = -Math.PI / 2.5;
            },
            (progress) => {},
            (error) => console.error(error)
        );

        // --- 5. Animation Loop ---
        const clock = new THREE.Clock();
        const headPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            controls.update();

            if (currentVrm) {
                // --- A. Proximity Check (Personal Space) ---
                const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                head.getWorldPosition(headPos);
                const distToCamera = camera.position.distanceTo(headPos);
                
                // If closer than 0.8m, activate blush
                inputState.isBlushing = (distToCamera < 0.8);

                // --- B. Expression Logic ---
                // Handle Blink Timer (Auto blink unless Happy)
                blinkTimer -= deltaTime;
                if (blinkTimer < 0 && !inputState.isHappy) {
                    blinkTimer = 2 + Math.random() * 4;
                    expressionSmoothness.blink = 1.0; // Trigger blink
                } else {
                    // Fade out blink quickly
                    expressionSmoothness.blink = THREE.MathUtils.lerp(expressionSmoothness.blink, 0, 10 * deltaTime);
                }

                // Lerp emotions
                const joyTarget = inputState.isHappy ? 1.0 : 0.0;
                const surprisedTarget = (inputState.isSurprised || inputState.isBlushing) ? 0.3 : 0.0; // Mild surprise if close
                
                expressionSmoothness.joy = THREE.MathUtils.lerp(expressionSmoothness.joy, joyTarget, 5 * deltaTime);
                expressionSmoothness.surprised = THREE.MathUtils.lerp(expressionSmoothness.surprised, surprisedTarget, 5 * deltaTime);

                // Apply expressions
                if (currentVrm.expressionManager) {
                    currentVrm.expressionManager.setValue('blink', expressionSmoothness.blink);
                    currentVrm.expressionManager.setValue('happy', expressionSmoothness.joy);
                    currentVrm.expressionManager.setValue('surprised', expressionSmoothness.surprised);
                    
                    // Try to find a blush shape key (standard VRMs usually have one)
                    // Note: Standard VRM 1.0 uses 'neutral', 'happy', 'angry', 'sad', 'relaxed'
                    // but many models have custom 'Blush'. We try to find it or map to 'relaxed'.
                    // For safety, we mix slight happy + surprised for a blush-like look if no specific blush key exists.
                    if (inputState.isBlushing) {
                         // Some models use 'joy' for blush, adding a small amount here
                         currentVrm.expressionManager.setValue('relaxed', 0.5); 
                    } else {
                         currentVrm.expressionManager.setValue('relaxed', 0); 
                    }
                }

                // --- C. Look At Camera Logic (Fixed Direction) ---
                const neck = currentVrm.humanoid.getNormalizedBoneNode('neck');
                const chest = currentVrm.humanoid.getNormalizedBoneNode('upperChest') || currentVrm.humanoid.getNormalizedBoneNode('chest');

                if (head) {
                    const dx = camera.position.x - headPos.x;
                    const dy = camera.position.y - headPos.y;
                    const dz = camera.position.z - headPos.z;

                    // Calculate angles
                    // Yaw (Left/Right)
                    let yaw = Math.atan2(dx, dz); 
                    
                    // Pitch (Up/Down)
                    const xzDist = Math.sqrt(dx * dx + dz * dz);
                    let pitch = Math.atan2(dy, xzDist);

                    // Clamp limits (Human neck limits)
                    yaw = THREE.MathUtils.clamp(yaw, -Math.PI / 2.5, Math.PI / 2.5); // 70 degrees max
                    pitch = THREE.MathUtils.clamp(pitch, -Math.PI / 4, Math.PI / 4); // 45 degrees max

                    // FIX: Inverted the pitch sign for rotation application.
                    // Previously -pitch caused inverted look. Now +pitch should fix "looking down when cam up".
                    // However, we must account for model rotation (Math.PI). 
                    // When model is rotated 180, +X rotation is Chin Down, -X is Chin Up.
                    // If Cam is Up -> dy is positive -> pitch is positive.
                    // We want Chin Up -> We need Negative X.
                    // So target Pitch Rotation = -pitch. 
                    // Wait, if the user said "she looks down" previously (when I used -pitch), 
                    // then I must use +pitch here.
                    
                    const targetPitch = pitch; // Flipping to Positive based on feedback
                    const targetYaw = yaw;

                    const lerpSpeed = 6.0 * deltaTime;

                    // Distribute rotation to make it look natural
                    // Chest handles 20%, Neck 30%, Head 50%
                    if (chest) {
                        chest.rotation.y = THREE.MathUtils.lerp(chest.rotation.y, targetYaw * 0.2, lerpSpeed);
                        chest.rotation.x = THREE.MathUtils.lerp(chest.rotation.x, targetPitch * 0.2, lerpSpeed);
                    }
                    if (neck) {
                        neck.rotation.y = THREE.MathUtils.lerp(neck.rotation.y, targetYaw * 0.3, lerpSpeed);
                        neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, targetPitch * 0.3, lerpSpeed);
                    }
                    
                    head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, targetYaw * 0.5, lerpSpeed);
                    head.rotation.x = THREE.MathUtils.lerp(head.rotation.x, targetPitch * 0.5, lerpSpeed);
                }

                currentVrm.update(deltaTime);
            }
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
