<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive VRM Companion</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202025; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; }
        
        #canvas-container { flex-grow: 1; position: relative; height: 100vh; overflow: hidden; }
        canvas { display: block; width: 100% !important; height: 100% !important; }
        
        #loader-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: #202025; display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 10; transition: opacity 0.5s ease;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255, 255, 255, 0.1); border-top: 4px solid #fff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #ui { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.8); pointer-events: none; user-select: none; opacity: 0; transition: opacity 1s ease; text-shadow: 0px 2px 4px rgba(0,0,0,0.8); z-index: 2; }

        #sidebar {
            width: 300px; min-width: 300px; height: 100vh; background: rgba(30, 30, 35, 0.85); backdrop-filter: blur(12px);
            border-left: 1px solid rgba(255, 255, 255, 0.1); padding: 20px; box-sizing: border-box; color: white;
            display: flex; flex-direction: column; gap: 12px; z-index: 5; box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            overflow-y: auto; overflow-x: hidden; transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        #sidebar.hidden { transform: translateX(100%); position: absolute; right: 0; }

        #sidebar::-webkit-scrollbar { width: 6px; }
        #sidebar::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        #sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }

        #sidebar-toggle {
            position: absolute; top: 20px; right: 320px; width: 40px; height: 40px; background: rgba(40, 40, 45, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2); color: white; border-radius: 50%; cursor: pointer; z-index: 6;
            display: flex; justify-content: center; align-items: center; font-size: 16px; transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1); box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #sidebar-toggle:hover { background: rgba(60, 60, 70, 0.9); transform: scale(1.05); }
        #sidebar-toggle.sidebar-hidden { right: 20px; transform: rotate(180deg); }

        #sidebar h2 { margin: 15px 0 5px 0; font-size: 1rem; font-weight: 600; color: #eee; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        #sidebar h2:first-child { margin-top: 0; }

        .controls { pointer-events: auto; display: flex; flex-direction: column; gap: 6px; }
        .bone-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        
        button {
            width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 8px 6px; border-radius: 6px; cursor: pointer; font-size: 12px; text-align: center;
            transition: all 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.25); border-color: rgba(255, 255, 255, 0.5); }
        button.active { background: rgba(100, 150, 255, 0.4); border-color: rgba(100, 150, 255, 0.8); box-shadow: 0 0 10px rgba(100, 150, 255, 0.2); }
        button.rig-active { background: rgba(255, 150, 100, 0.4); border-color: rgba(255, 150, 100, 0.8); box-shadow: 0 0 10px rgba(255, 150, 100, 0.2); }

        .movement-controls label { font-size: 0.8rem; color: #ccc; display: block; margin-top: 5px; text-align: left; }
        input[type="range"] { width: 100%; margin-top: 5px; cursor: pointer; accent-color: #6496ff; }

        #speak-btn { margin-top: 15px; margin-bottom: 20px; background: rgba(100, 255, 150, 0.2); border-color: rgba(100, 255, 150, 0.4); padding: 12px; font-size: 14px; }
        #speak-btn:hover { background: rgba(100, 255, 150, 0.4); }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
                "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container">
        <div id="loader-container">
            <div class="spinner"></div>
            <div id="loader-text">Loading Model...</div>
        </div>
        <div id="ui">Move your mouse to interact ‚Ä¢ Click the face for reactions</div>
        <button id="sidebar-toggle">‚ñ∂</button>
    </div>

    <div id="sidebar">
        <h2>Expressions</h2>
        <div class="controls bone-grid">
            <button class="expr-btn active" data-expr="neutral">Neutral üòê</button>
            <button class="expr-btn" data-expr="happy">Happy üòä</button>
            <button class="expr-btn" data-expr="angry">Angry üò†</button>
            <button class="expr-btn" data-expr="sad">Sad üò¢</button>
            <button class="expr-btn" data-expr="surprised">Surprise üò≤</button>
            <button class="expr-btn" data-expr="relaxed">Blush üòå</button>
        </div>

        <h2>Core Rig</h2>
        <div class="controls bone-grid">
            <button class="rig-btn" data-bone="head">Head</button>
            <button class="rig-btn" data-bone="neck">Neck</button>
            <button class="rig-btn" data-bone="upperChest">U. Chest</button>
            <button class="rig-btn" data-bone="chest">Chest</button>
            <button class="rig-btn" data-bone="spine">Spine</button>
            <button class="rig-btn" data-bone="hips">Hips</button>
        </div>

        <h2>Arms & Shoulders</h2>
        <div class="controls bone-grid">
            <button class="rig-btn" data-bone="rightShoulder">R. Shoulder</button>
            <button class="rig-btn" data-bone="leftShoulder">L. Shoulder</button>
            <button class="rig-btn" data-bone="rightUpperArm">R. Up. Arm</button>
            <button class="rig-btn" data-bone="leftUpperArm">L. Up. Arm</button>
            <button class="rig-btn" data-bone="rightLowerArm">R. Elbow</button>
            <button class="rig-btn" data-bone="leftLowerArm">L. Elbow</button>
            <button class="rig-btn" data-bone="rightHand">R. Wrist</button>
            <button class="rig-btn" data-bone="leftHand">L. Wrist</button>
        </div>

        <h2>Legs</h2>
        <div class="controls bone-grid">
            <button class="rig-btn" data-bone="rightUpperLeg">R. Up. Leg</button>
            <button class="rig-btn" data-bone="leftUpperLeg">L. Up. Leg</button>
            <button class="rig-btn" data-bone="rightLowerLeg">R. Knee</button>
            <button class="rig-btn" data-bone="leftLowerLeg">L. Knee</button>
            <button class="rig-btn" data-bone="rightFoot">R. Ankle</button>
            <button class="rig-btn" data-bone="leftFoot">L. Ankle</button>
            <button class="rig-btn" data-bone="rightToes">R. Toes</button>
            <button class="rig-btn" data-bone="leftToes">L. Toes</button>
        </div>

        <h2>Left Fingers</h2>
        <div class="controls bone-grid">
            <button class="rig-btn" data-bone="leftThumbProximal">L. Thumb</button>
            <button class="rig-btn" data-bone="leftIndexProximal">L. Index</button>
            <button class="rig-btn" data-bone="leftMiddleProximal">L. Middle</button>
            <button class="rig-btn" data-bone="leftRingProximal">L. Ring</button>
            <button class="rig-btn" data-bone="leftLittleProximal">L. Pinky</button>
        </div>

        <h2>Right Fingers</h2>
        <div class="controls bone-grid">
            <button class="rig-btn" data-bone="rightThumbProximal">R. Thumb</button>
            <button class="rig-btn" data-bone="rightIndexProximal">R. Index</button>
            <button class="rig-btn" data-bone="rightMiddleProximal">R. Middle</button>
            <button class="rig-btn" data-bone="rightRingProximal">R. Ring</button>
            <button class="rig-btn" data-bone="rightLittleProximal">R. Pinky</button>
        </div>

        <h2>Movement Rules</h2>
        <div class="controls movement-controls">
            <label for="breath-speed">Breathing Speed</label>
            <input type="range" id="breath-speed" min="0" max="5" step="0.1" value="1.2">
            
            <label for="sway-amount">Body Sway Intensity</label>
            <input type="range" id="sway-amount" min="0" max="3" step="0.1" value="1.0">
            
            <label for="look-intensity">Mouse Tracking</label>
            <input type="range" id="look-intensity" min="0" max="1" step="0.05" value="0.7">
        </div>

        <div class="controls">
            <button id="speak-btn">Simulate Speech üé§</button>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        const canvasContainer = document.getElementById('canvas-container');

        // --- 1. Scene Setup ---
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        canvasContainer.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30.0, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.4, 1.6); 

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1.0, 2.0, 2.0);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));

        // --- 2. Controls & Gizmo ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1.3, 0);
        controls.maxDistance = 4.0;

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.setMode('rotate'); 
        transformControl.setSpace('local'); 
        scene.add(transformControl.getHelper());

        // --- 3. Full VRM Bone Limits (Anti-Fracture System) ---
        const boneLimits = {
            head: { min: {x: -0.5, y: -0.8, z: -0.3}, max: {x: 0.5, y: 0.8, z: 0.3} },
            neck: { min: {x: -0.6, y: -1.2, z: -0.5}, max: {x: 0.6, y: 1.2, z: 0.5} },
            upperChest: { min: {x: -0.2, y: -0.3, z: -0.2}, max: {x: 0.2, y: 0.3, z: 0.2} },
            chest: { min: {x: -0.3, y: -0.4, z: -0.3}, max: {x: 0.3, y: 0.4, z: 0.3} },
            spine: { min: {x: -0.4, y: -0.5, z: -0.4}, max: {x: 0.4, y: 0.5, z: 0.4} },
            hips: { min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            
            // Arms
            rightShoulder: { min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            leftShoulder: { min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            rightUpperArm: { min: {x: -2.0, y: -1.5, z: -3.0}, max: {x: 2.0, y: 1.5, z: 1.0} },
            leftUpperArm: { min: {x: -2.0, y: -1.5, z: -1.0}, max: {x: 2.0, y: 1.5, z: 3.0} },
            rightLowerArm: { min: {x: -2.8, y: -1.0, z: -2.8}, max: {x: 0.2, y: 1.0, z: 0.2} },
            leftLowerArm: { min: {x: -2.8, y: -1.0, z: -0.2}, max: {x: 0.2, y: 1.0, z: 2.8} },
            rightHand: { min: {x: -1.0, y: -0.5, z: -1.0}, max: {x: 1.0, y: 0.5, z: 1.0} },
            leftHand: { min: {x: -1.0, y: -0.5, z: -1.0}, max: {x: 1.0, y: 0.5, z: 1.0} },
            
            // Legs
            rightUpperLeg: { min: {x: -2.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            leftUpperLeg: { min: {x: -2.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            rightLowerLeg: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 2.8, y: 0.1, z: 0.1} },
            leftLowerLeg: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 2.8, y: 0.1, z: 0.1} },
            rightFoot: { min: {x: -0.8, y: -0.5, z: -0.5}, max: {x: 0.8, y: 0.5, z: 0.5} },
            leftFoot: { min: {x: -0.8, y: -0.5, z: -0.5}, max: {x: 0.8, y: 0.5, z: 0.5} },
            rightToes: { min: {x: -0.5, y: 0, z: 0}, max: {x: 0.8, y: 0, z: 0} },
            leftToes: { min: {x: -0.5, y: 0, z: 0}, max: {x: 0.8, y: 0, z: 0} },

            // Fingers
            leftThumbProximal: { min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            leftIndexProximal: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 0.1, y: 0.1, z: 1.5} },
            leftMiddleProximal: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 0.1, y: 0.1, z: 1.5} },
            leftRingProximal: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 0.1, y: 0.1, z: 1.5} },
            leftLittleProximal: { min: {x: -0.1, y: -0.1, z: -0.1}, max: {x: 0.1, y: 0.1, z: 1.5} },
            
            rightThumbProximal: { min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5} },
            rightIndexProximal: { min: {x: -0.1, y: -0.1, z: -1.5}, max: {x: 0.1, y: 0.1, z: 0.1} },
            rightMiddleProximal: { min: {x: -0.1, y: -0.1, z: -1.5}, max: {x: 0.1, y: 0.1, z: 0.1} },
            rightRingProximal: { min: {x: -0.1, y: -0.1, z: -1.5}, max: {x: 0.1, y: 0.1, z: 0.1} },
            rightLittleProximal: { min: {x: -0.1, y: -0.1, z: -1.5}, max: {x: 0.1, y: 0.1, z: 0.1} }
        };

        transformControl.addEventListener('change', () => {
            if (activeControlBone && boneLimits[activeControlBone] && currentVrm) {
                const bone = currentVrm.humanoid.getNormalizedBoneNode(activeControlBone);
                const limits = boneLimits[activeControlBone];
                if (bone) {
                    bone.rotation.x = THREE.MathUtils.clamp(bone.rotation.x, limits.min.x, limits.max.x);
                    bone.rotation.y = THREE.MathUtils.clamp(bone.rotation.y, limits.min.y, limits.max.y);
                    bone.rotation.z = THREE.MathUtils.clamp(bone.rotation.z, limits.min.z, limits.max.z);
                }
            }
        });
        transformControl.addEventListener('dragging-changed', (event) => controls.enabled = !event.value);

        // --- 4. State Variables ---
        let currentVrm = null; let activeControlBone = null; 
        let blinkTimer = 0; let isDoubleBlinking = false; let idleTime = 0;
        let attentionTimer = 3.0; let isDistracted = false; const distractionOffset = new THREE.Vector3();
        let guiEmotion = 'neutral'; const inputState = { isHappy: false, isSurprised: false }; 
        const expressionTargets = { happy: 0, angry: 0, sad: 0, surprised: 0, relaxed: 0, blink: 0 };
        const currentExpressions = { happy: 0, angry: 0, sad: 0, surprised: 0, relaxed: 0, blink: 0 };
        const lookAtTarget = new THREE.Object3D(); scene.add(lookAtTarget);
        let targetSaccade = new THREE.Vector3(); let currentSaccade = new THREE.Vector3(); 
        let isSpeaking = false; let speakTimer = 0;
        const visemeTargets = { aa: 0, ih: 0, ou: 0, ee: 0, oh: 0 }; const currentVisemes = { aa: 0, ih: 0, ou: 0, ee: 0, oh: 0 };
        const visemeKeys = Object.keys(visemeTargets);
        let userControls = { breathSpeed: 1.2, swayAmount: 1.0, lookIntensity: 0.7 };

        // --- 5. Interactions ---
        const mouse = new THREE.Vector2();
        // Variables for the new White Eyes fix
        let targetX = 0; let targetY = 0;

        window.addEventListener('mousemove', (event) => {
            const rect = canvasContainer.getBoundingClientRect();
            if (event.clientX > rect.width) return;
            mouse.x = (event.clientX / rect.width) * 2 - 1; 
            mouse.y = -(event.clientY / rect.height) * 2 + 1;
            idleTime = 0; 
            
            // Map the mouse position directly to a spot on the camera plane
            targetX = mouse.x * 1.5;
            targetY = mouse.y * 1.0 + 1.4; // 1.4 is her head height
        });

        // Face Clicks
        const raycaster = new THREE.Raycaster();
        canvasContainer.addEventListener('mousedown', (event) => {
            if (!currentVrm || transformControl.dragging) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(currentVrm.scene.children, true);
            if (intersects.length > 0) {
                const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                const headPos = new THREE.Vector3(); head.getWorldPosition(headPos);
                if (intersects[0].point.distanceTo(headPos) < 0.25) {
                    inputState.isHappy = true; setTimeout(() => inputState.isHappy = false, 2000);
                    isDistracted = false; attentionTimer = 5.0; 
                } else {
                    inputState.isSurprised = true; setTimeout(() => inputState.isSurprised = false, 1000);
                }
            }
        });

        // GUI Listeners
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('hidden'); sidebarToggle.classList.toggle('sidebar-hidden');
            setTimeout(() => window.dispatchEvent(new Event('resize')), 400); 
        });

        document.querySelectorAll('.expr-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.expr-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active'); guiEmotion = btn.getAttribute('data-expr');
            });
        });

        document.querySelectorAll('.rig-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!currentVrm) return;
                const targetBone = btn.getAttribute('data-bone');
                
                if (activeControlBone === targetBone) {
                    transformControl.detach(); activeControlBone = null; btn.classList.remove('rig-active');
                } else {
                    document.querySelectorAll('.rig-btn').forEach(b => b.classList.remove('rig-active'));
                    const boneNode = currentVrm.humanoid.getNormalizedBoneNode(targetBone);
                    if (boneNode) {
                        transformControl.attach(boneNode); activeControlBone = targetBone; btn.classList.add('rig-active');
                    }
                }
            });
        });

        document.getElementById('speak-btn').addEventListener('click', () => { isSpeaking = true; speakTimer = 4.0; });
        document.getElementById('breath-speed').addEventListener('input', (e) => userControls.breathSpeed = parseFloat(e.target.value));
        document.getElementById('sway-amount').addEventListener('input', (e) => userControls.swayAmount = parseFloat(e.target.value));
        document.getElementById('look-intensity').addEventListener('input', (e) => userControls.lookIntensity = parseFloat(e.target.value));

        // --- 6. Load VRM ---
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));

        loader.load(
            '../VRM/Mafuyu_Black_Fit.vrm', // <-- REPLACE WITH YOUR MODEL PATH
            (gltf) => {
                const vrm = gltf.userData.vrm;
                VRMUtils.removeUnnecessaryVertices(gltf.scene); VRMUtils.removeUnnecessaryJoints(gltf.scene);
                if (vrm.lookAt) { vrm.lookAt.target = lookAtTarget; vrm.lookAt.autoUpdate = true; }
                vrm.scene.traverse((obj) => { if (obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; } });
                scene.add(vrm.scene); currentVrm = vrm; vrm.scene.rotation.y = Math.PI; 

                // Relax Arms
                const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                if (leftArm) leftArm.rotation.z = Math.PI / 2.5;
                if (rightArm) rightArm.rotation.z = -Math.PI / 2.5;

                document.getElementById('loader-container').style.opacity = '0';
                setTimeout(() => document.getElementById('loader-container').style.display = 'none', 500);
                document.getElementById('ui').style.opacity = '1';
            },
            (progress) => {}, (error) => console.error('Failed to load VRM:', error)
        );

        // --- 7. Animation Loop ---
        const clock = new THREE.Clock(); const headPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); const elapsedTime = clock.getElapsedTime();
            controls.update();

            if (currentVrm) {
                idleTime += deltaTime;
                const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                const neck = currentVrm.humanoid.getNormalizedBoneNode('neck');
                const spine = currentVrm.humanoid.getNormalizedBoneNode('spine');
                const chest = currentVrm.humanoid.getNormalizedBoneNode('upperChest') || currentVrm.humanoid.getNormalizedBoneNode('chest');
                
                if (head) head.getWorldPosition(headPos);

                attentionTimer -= deltaTime;
                if (attentionTimer <= 0 && !inputState.isHappy) {
                    isDistracted = !isDistracted;
                    if (isDistracted) { 
                        // Distraction dot is safely in front of her face (+Z direction)
                        distractionOffset.set((Math.random() - 0.5) * 1.5, -0.2 - Math.random() * 0.4, 1.5); 
                        attentionTimer = 1.0 + Math.random() * 2.0; 
                    } 
                    else { attentionTimer = 3.0 + Math.random() * 5.0; }
                }

                // THE NEW WHITE EYES FIX: Put the dot exactly where the camera glass is (Z = 1.6)
                let baseTargetPosition = isDistracted ? 
                    headPos.clone().add(distractionOffset) : 
                    new THREE.Vector3(camera.position.x + targetX, targetY, camera.position.z); 
                
                if (Math.random() < 0.02) targetSaccade.set((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, 0);
                currentSaccade.lerp(targetSaccade, 4 * deltaTime);
                lookAtTarget.position.lerp(baseTargetPosition.add(currentSaccade), 3 * deltaTime);

                const swayBase = Math.sin(elapsedTime * userControls.breathSpeed);
                const swaySide = Math.cos(elapsedTime * (userControls.breathSpeed * 0.8));

                if (spine && activeControlBone !== 'spine') {
                    spine.rotation.x = swayBase * 0.015 * userControls.swayAmount;
                    spine.rotation.z = swaySide * 0.01 * userControls.swayAmount;
                }
                if (chest && activeControlBone !== 'chest' && activeControlBone !== 'upperChest') {
                    chest.rotation.x = Math.sin(elapsedTime * userControls.breathSpeed + 0.5) * 0.015 * userControls.swayAmount;
                }

                if (neck && activeControlBone !== 'neck' && activeControlBone !== 'head') {
                    if (!isDistracted) {
                        neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, -mouse.y * (Math.PI / 6) * userControls.lookIntensity, 5 * deltaTime);
                        neck.rotation.y = THREE.MathUtils.lerp(neck.rotation.y, mouse.x * (Math.PI / 4) * userControls.lookIntensity, 5 * deltaTime);
                    } else {
                        neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, 0, 2 * deltaTime);
                        neck.rotation.y = THREE.MathUtils.lerp(neck.rotation.y, 0, 2 * deltaTime);
                    }
                }

                Object.keys(expressionTargets).forEach(key => expressionTargets[key] = 0);
                if (guiEmotion !== 'neutral' && expressionTargets[guiEmotion] !== undefined) expressionTargets[guiEmotion] = 1.0;
                if (inputState.isHappy) { Object.keys(expressionTargets).forEach(key => expressionTargets[key] = 0); expressionTargets.happy = 1.0; } 
                else if (inputState.isSurprised) { Object.keys(expressionTargets).forEach(key => expressionTargets[key] = 0); expressionTargets.surprised = 0.8; } 
                else if (guiEmotion === 'neutral' && idleTime > 5.0) { expressionTargets.relaxed = 0.2; }

                blinkTimer -= deltaTime;
                if (blinkTimer < 0 && !inputState.isHappy && guiEmotion !== 'happy' && guiEmotion !== 'angry') {
                    expressionTargets.blink = 1.0;
                    if (!isDoubleBlinking && Math.random() < 0.2) { isDoubleBlinking = true; blinkTimer = 0.15; } 
                    else { isDoubleBlinking = false; blinkTimer = 2 + Math.random() * 4; }
                }

                if (isSpeaking) {
                    speakTimer -= deltaTime;
                    if (speakTimer <= 0) { isSpeaking = false; visemeKeys.forEach(v => visemeTargets[v] = 0); } 
                    else if (Math.random() < 0.12) { visemeKeys.forEach(v => visemeTargets[v] = 0); visemeTargets[visemeKeys[Math.floor(Math.random() * visemeKeys.length)]] = 0.4 + Math.random() * 0.6; }
                }

                if (currentVrm.expressionManager) {
                    Object.keys(currentExpressions).forEach(key => {
                        currentExpressions[key] = THREE.MathUtils.lerp(currentExpressions[key], expressionTargets[key], (key === 'blink' ? 15 : 6) * deltaTime);
                        currentVrm.expressionManager.setValue(key, currentExpressions[key]);
                    });
                    visemeKeys.forEach(v => {
                        currentVisemes[v] = THREE.MathUtils.lerp(currentVisemes[v], visemeTargets[v], 12 * deltaTime);
                        currentVrm.expressionManager.setValue(v, currentVisemes[v]);
                    });
                }
                
                currentVrm.update(deltaTime);
            }
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const width = canvasContainer.clientWidth; const height = canvasContainer.clientHeight;
            camera.aspect = width / height; camera.updateProjectionMatrix();
            renderer.setSize(width, height); renderer.render(scene, camera);
        });
    </script>
</body>
</html>
